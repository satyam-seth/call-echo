var H = Object.defineProperty; var N = (t, e, n) => e in t ? H(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var c = (t, e, n) => N(t, typeof e != "symbol" ? e + "" : e, n); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const a of o.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function i(r) { if (r.ep) return; r.ep = !0; const o = n(r); fetch(r.href, o) } })(); class C { static async queryPermissionStatus(e) { if (!("permissions" in navigator)) return console.warn(`Permission '${e}' is not supported by this browser.`), null; try { return (await navigator.permissions.query({ name: e })).state } catch (n) { return console.error(`Error querying permission '${e}':`, n), null } } static async checkPermission(e) { try { const n = await this.queryPermissionStatus(e); return n === "granted" ? !0 : (n === "prompt" && console.warn(`Permission '${e}' requires a specific API call to trigger the prompt.`), !1) } catch (n) { return console.error(`Error checking permission '${e}':`, n), !1 } } static async watchPermissionState(e, n) { if (!("permissions" in navigator)) { console.warn(`Permission '${e}' is not supported by this browser.`); return } try { const i = await navigator.permissions.query({ name: e }); n(i.state), i.onchange = () => { n(i.state) } } catch (i) { console.error(`Error watching permission '${e}':`, i) } } } const K = ["microphone", "camera", "geolocation", "notifications"]; function w(t, e) { const n = document.createElement("button"); return n.innerText = t, n.addEventListener("click", e), n } function W(t) { return w(`Get ${t} permission Status`, async () => { const e = await C.queryPermissionStatus(t); alert(e ? `Permission ${t} status: ${e}` : `Permission ${t} is not supported or an error occurred.`) }) } function Y(t) { return w(`Check have ${t} permission or not`, async () => { const e = await C.checkPermission(t); alert(e ? `Have ${t} permission.` : `Do not have ${t} Permission.`) }) } function J(t) { return w(`Watch ${t} permission state`, async () => { await C.watchPermissionState(t, e => { alert(`Permission ${t} state changed to: ${e}`) }) }) } function Q() { const t = document.createElement("div"); t.className = "permission-container"; const e = document.createElement("h2"); return e.innerText = "Permission Demo", t.appendChild(e), K.forEach(n => { const i = document.createElement("div"); i.className = "permission-section", i.innerHTML = `<h3>${n}</h3>`, i.appendChild(W(n)), i.appendChild(Y(n)), i.appendChild(J(n)), t.appendChild(i) }), t } const m = class m { constructor() { c(this, "_userConstraints"); c(this, "_displayConstraints"); c(this, "_userStream", null); c(this, "_displayStream", null); c(this, "_audioInputDevices", []); c(this, "_audioOutputDevices", []); c(this, "_videoInputDevices", []); c(this, "nextCallbackId", 0); c(this, "deviceChangeCallbacks", new Map); c(this, "displayStreamEndCallbacks", new Map); this.startListeningToDeviceChanges() } static get instance() { return m._instance || (m._instance = new m), m._instance } async getDisplayMedia(e) { try { if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) throw new Error("getDisplayMedia is not supported in this browser."); return this.stopDisplayStream(), this._displayConstraints = e, this._displayStream = await navigator.mediaDevices.getDisplayMedia(this._displayConstraints), this._displayStream.getVideoTracks().forEach(n => { n.onended = () => { console.log("Display track ended"), this.stopDisplayStream(), this.notifyDisplayStreamEnd() } }), this._displayStream } catch (n) { throw console.error("Error accessing display media.", n), n } } stopDisplayStream() { var e; (e = this._displayStream) == null || e.getTracks().forEach(n => n.stop()), this._displayStream = null } get displayStream() { return this._displayStream } get displayStreamConstraints() { return this._displayConstraints } get displayStreamActive() { return !!this._displayStream && this._displayStream.getTracks().some(e => e.readyState === "live") } notifyDisplayStreamEnd() { console.log("Notifying display stream end callbacks.", this.deviceChangeCallbacks.size); for (const e of this.displayStreamEndCallbacks.values()) e() } unregisterDisplayStreamEnd(e) { this.displayStreamEndCallbacks.delete(e) } registerDisplayStreamEnd(e) { const n = this.nextCallbackId++; return this.displayStreamEndCallbacks.set(n, e), n } async getUserMedia(e) { try { if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error("getUserMedia is not supported in this browser."); return this.stopMediaStream(), this._userConstraints = e, this._userStream = await navigator.mediaDevices.getUserMedia(this._userConstraints), this._userStream } catch (n) { throw console.error("Error accessing media devices.", n), n } } stopMediaStream() { var e; (e = this._userStream) == null || e.getTracks().forEach(n => n.stop()), this._userStream = null } toggleUserTrack(e) { var n; (n = this._userStream) == null || n.getTracks().forEach(i => { i.kind === e && (i.enabled = !i.enabled) }) } enableUserTrack(e) { var n; (n = this._userStream) == null || n.getTracks().forEach(i => { i.kind === e && (i.enabled = !0) }) } disableUserTrack(e) { var n; (n = this._userStream) == null || n.getTracks().forEach(i => { i.kind === e && (i.enabled = !1) }) } isUserTrackEnabled(e) { var n; return ((n = this._userStream) == null ? void 0 : n.getTracks().some(i => i.kind === e && i.enabled)) ?? !1 } get userStream() { return this._userStream } get userStreamConstraints() { return this._userConstraints } async enumerateDevices() { if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) throw new Error("enumerateDevices is not supported in this browser."); try { const e = await navigator.mediaDevices.enumerateDevices(); return this._audioInputDevices = e.filter(n => n.kind === "audioinput"), this._videoInputDevices = e.filter(n => n.kind === "videoinput"), this._audioOutputDevices = e.filter(n => n.kind === "audiooutput"), e } catch (e) { throw console.error("Error enumerating devices:", e), e } } get audioInputDevices() { return this._audioInputDevices } get audioOutputDevices() { return this._audioOutputDevices } get videoInputDevices() { return this._videoInputDevices } async setInputDevice(e, n) { let i = !0, r = !0; this._userStream && (i = this.isUserTrackEnabled("audio"), r = this.isUserTrackEnabled("video")); try { const o = await this.getUserMedia(e); i || this.disableUserTrack("audio"), r || this.disableUserTrack("video"), n(o) } catch (o) { console.error("Error setting update input device:", o) } } async setAudioInputDevice(e, n) { const i = { ...this._userConstraints, audio: { deviceId: { exact: e } } }; try { return await this.setInputDevice(i, n), !0 } catch (r) { return console.error("Error setting audio input device:", r), !1 } } async setVideoInputDevice(e, n) { const i = { ...this._userConstraints, video: { deviceId: { exact: e } } }; try { return await this.setInputDevice(i, n), !0 } catch (r) { return console.error("Error setting video input device:", r), !1 } } async setAudioOutputDevice(e, n) { if (typeof e.sinkId < "u") { try { console.log("Setting audio output device to:", n), await e.setSinkId(n) } catch (i) { let r = i; i.name === "SecurityError" && (r = `You need to use HTTPS for selecting audio output device: ${i}`), console.error(r) } return !0 } else return console.warn("Browser does not support output device selection."), !1 } get currentAudioInputDeviceId() { var e, n; return (n = (e = this._userStream) == null ? void 0 : e.getAudioTracks()[0]) == null ? void 0 : n.getSettings().deviceId } get currentVideoInputDeviceId() { var e, n; return (n = (e = this._userStream) == null ? void 0 : e.getVideoTracks()[0]) == null ? void 0 : n.getSettings().deviceId } registerDeviceChange(e) { const n = this.nextCallbackId++; return this.deviceChangeCallbacks.set(n, e), n } unregisterDeviceChange(e) { this.deviceChangeCallbacks.delete(e) } notifyDeviceChange() { console.log("Notifying device change callbacks.", this.deviceChangeCallbacks.size); for (const e of this.deviceChangeCallbacks.values()) e() } async startListeningToDeviceChanges() { if (!navigator.mediaDevices || !navigator.mediaDevices.addEventListener) { console.warn("Device change events are not supported in this browser."); return } navigator.mediaDevices.addEventListener("devicechange", async () => { if (console.log("Device change detected."), await this.enumerateDevices(), this._userStream) { const e = this.currentAudioInputDeviceId, n = this.currentVideoInputDeviceId; (e && !this._audioInputDevices.some(i => i.deviceId === e) || n && !this._videoInputDevices.some(i => i.deviceId === n)) && this.stopMediaStream() } this.notifyDeviceChange() }) } }; c(m, "_instance"); let s = m, b = null, f = null; function g(t, e, n, i = !1) { const r = document.createElement("button"); return r.id = e, r.disabled = i, r.innerText = t, r.addEventListener("click", n), r } function p(t, e) { const n = document.querySelector(`#${t}`); n.disabled = e } function R() { p("stop-local-user-stream-btn", !1) } function X() { p("stop-local-display-stream-btn", !1) } function A() { const t = document.querySelector("#toggle-user-audio-btn"); t.disabled = !1, t.innerText = "Disable User Audio" } function Z() { const t = document.querySelector("#toggle-user-audio-btn"); t.disabled = !0, t.innerText = "Enable User Audio" } function ee() { const t = document.querySelector("#toggle-user-video-btn"); t.disabled = !1, t.innerText = "Disable User Video" } function te() { const t = document.querySelector("#toggle-user-video-btn"); t.disabled = !0, t.innerText = "Enable User Video" } function _() { p("local-user-stream-video-btn", !0) } function y() { p("local-user-stream-video-btn", !1) } function $() { p("local-user-stream-audio-btn", !0) } function S() { p("local-user-stream-audio-btn", !1) } function q() { p("local-display-stream-btn", !0) } function D() { p("local-display-stream-btn", !1) } function ne(t) { s.instance.toggleUserTrack("audio"); const e = s.instance.isUserTrackEnabled("audio"); t.target.innerText = e ? "Disable User Audio" : "Enable User Audio" } function ie() { return g("Disable User Audio", "toggle-user-audio-btn", ne, !0) } function re(t) { s.instance.toggleUserTrack("video"); const e = s.instance.isUserTrackEnabled("video"); t.target.innerText = e ? "Disable User Video" : "Enable User Video" } function oe() { return g("Disable Video", "toggle-user-video-btn", re, !0) } function se(t) { const e = document.querySelector("audio#user-audio"); e && (e.srcObject = t) } function ae(t) { const e = document.querySelector("video#user-video"); e && (e.srcObject = t) } function ce() { const t = document.querySelector("video#user-video"), e = document.querySelector("audio#user-audio"); t && (t.srcObject = null, t.remove()), e && (e.srcObject = null, e.remove()) } function de() { const t = document.querySelector("video#display-video"); t && (t.srcObject = null, t.remove()) } function V() { const t = document.querySelector(".user-audio-input-devices-selector-container"), e = document.querySelector(".user-audio-output-devices-selector-container"), n = document.querySelector(".user-video-input-devices-selector-container"); t == null || t.remove(), e == null || e.remove(), n == null || n.remove() } function ue() { return g("Stop local user stream", "stop-local-user-stream-btn", async t => { t.target.disabled = !0, S(), y(), D(), Z(), te(), ce(), V(), ve(), s.instance.stopMediaStream() }, !0) } function L() { S(), y(), D(), de(), E(!1), he(), s.instance.stopDisplayStream() } function le() { return g("Stop local display stream", "stop-local-display-stream-btn", async t => { t.target.disabled = !0, L() }, !0) } function P(t, e) { const n = document.createElement("video"); return n.id = e, n.srcObject = t, n.autoplay = !0, n.controls = !0, n.style.width = "100%", n.style.height = "100%", n } function pe(t, e) { const n = document.createElement("audio"); return n.id = e, n.srcObject = t, n.autoplay = !0, n.controls = !0, n } function U(t, e, n, i) { const r = document.createElement("select"); return r.id = t, e.forEach(o => { const a = document.createElement("option"); a.value = o.deviceId, a.textContent = o.label || `Device ${o.deviceId}`, a.selected = i !== void 0 && o.deviceId === i, r.appendChild(a) }), r.addEventListener("change", async o => { const a = o.target.value; await n(a) }), r } function I(t, e) { const n = document.createElement("div"); n.className = "user-audio-input-devices-selector-container"; const i = "user-audio-input-devices-selector", r = document.createElement("label"); r.textContent = "User Audio Input Devices:", r.setAttribute("for", i), n.appendChild(r); const o = U(i, t, async a => { await s.instance.setAudioInputDevice(a, se) }, e); return n.appendChild(o), n } function k(t) { const e = document.createElement("div"); e.className = "user-audio-output-devices-selector-container"; const n = "user-audio-output-devices-selector", i = document.createElement("label"); return i.textContent = "Audio Output Devices:", i.setAttribute("for", n), e.appendChild(i), e.appendChild(U(n, t, async r => { const o = document.querySelector("video#user-video"); o && await s.instance.setAudioOutputDevice(o, r); const a = document.querySelector("audio#user-audio"); a && await s.instance.setAudioOutputDevice(a, r) })), e } function me() { const t = document.createElement("div"); t.className = "display-surface-selector-container"; const e = "display-surface-selector", n = document.createElement("label"); n.textContent = "Display Surface:", n.setAttribute("for", e), t.appendChild(n); const i = document.createElement("select"); return i.id = e, [{ title: "Show default sharing options", value: "" }, { title: "Prefer to share a browser tab", value: "browser" }, { title: "Prefer to share a window", value: "window" }, { title: "Prefer to share an entire screen", value: "monitor" }].forEach(o => { const a = document.createElement("option"); a.value = o.value, a.textContent = o.title, i.appendChild(a) }), t.appendChild(i), t } function ge() { return document.querySelector("#display-surface-selector").value } function E(t) { const e = document.querySelector("#display-surface-selector"); e.disabled = t } function O(t, e) { const n = document.createElement("div"); n.className = "user-video-input-devices-selector-container"; const i = "user-video-input-devices-selector", r = document.createElement("label"); r.textContent = "Video Input Devices:", r.setAttribute("for", i), n.appendChild(r); const o = U(i, t, async a => { await s.instance.setVideoInputDevice(a, ae) }, e); return n.appendChild(o), n } function ve() { b !== null && (s.instance.unregisterDeviceChange(b), b = null) } function x(t) { b = s.instance.registerDeviceChange(async () => { if (console.log("Device changed"), s.instance.userStream === null) { console.info("Media stream is null, getting new stream"); const o = await s.instance.getUserMedia({ video: !t, audio: !0 }), a = document.querySelector("video#user-video"), h = document.querySelector("audio#user-audio"); h && t ? (console.info("Updating audio stream to audio element"), h.srcObject = o) : a && (console.info("Updating video stream to video element"), a.srcObject = o) } const e = document.querySelector(".media-container"); V(); const n = s.instance.audioInputDevices, i = s.instance.audioOutputDevices, r = s.instance.currentAudioInputDeviceId; if (e.append(I(n, r)), e.append(k(i)), !t) { const o = s.instance.videoInputDevices, a = s.instance.currentVideoInputDeviceId; e.append(O(o, a)) } }) } function he() { f !== null && (s.instance.unregisterDisplayStreamEnd(f), f = null) } function be() { s.instance.displayStream !== null && (f = s.instance.registerDisplayStreamEnd(async () => { console.log("Display stream end"), L() })) } function fe() { return g("Get local user video stream", "local-user-stream-video-btn", async t => { t.target.disabled = !0, $(), q(); let e; try { e = await s.instance.getUserMedia({ video: !0, audio: !0 }) } catch (B) { t.target.disabled = !1, S(), D(), B.name === "NotAllowedError" ? window.alert("User denied permission to share video") : window.alert("Failed to get video stream: " + B); return } const n = document.querySelector(".media-container"); n.appendChild(P(e, "user-video")), await s.instance.enumerateDevices(); const i = s.instance.audioInputDevices, r = s.instance.audioOutputDevices, o = s.instance.videoInputDevices, a = s.instance.currentAudioInputDeviceId, h = s.instance.currentVideoInputDeviceId; n.append(I(i, a)), n.append(k(r)), n.append(O(o, h)), x(!1), R(), A(), ee() }) } function ye() { return g("Get local user audio stream", "local-user-stream-audio-btn", async t => { t.target.disabled = !0, _(), q(); let e; try { e = await s.instance.getUserMedia({ audio: !0 }) } catch (a) { t.target.disabled = !1, y(), D(), a.name === "NotAllowedError" ? window.alert("User denied permission to share audio") : window.alert("Failed to get audio stream: " + a); return } const n = document.querySelector(".media-container"); n.appendChild(pe(e, "user-audio")), await s.instance.enumerateDevices(); const i = s.instance.audioInputDevices, r = s.instance.audioOutputDevices, o = s.instance.currentAudioInputDeviceId; n.append(I(i, o)), n.append(k(r)), x(!0), R(), A() }) } function Se() { return g("Get local display stream", "local-display-stream-btn", async t => { t.target.disabled = !0, _(), $(), E(!0); const e = { video: !0, audio: !0 }, n = ge(); n !== "" && (e.video = { displaySurface: n }); let i; try { i = await s.instance.getDisplayMedia(e) } catch (o) { t.target.disabled = !1, y(), S(), E(!1), o.name === "NotAllowedError" ? window.alert("User denied permission to share display") : window.alert("Failed to get display stream: " + o); return } document.querySelector(".media-container").appendChild(P(i, "display-video")), be(), X() }) } function De() { const t = document.createElement("div"); t.className = "media-container"; const e = document.createElement("h2"); return e.innerText = "Media Demo", t.appendChild(e), t.appendChild(fe()), t.appendChild(ye()), t.appendChild(ue()), t.appendChild(ie()), t.appendChild(oe()), t.appendChild(Se()), t.appendChild(le()), t.appendChild(me()), t } class Ee { constructor() { c(this, "mediaRecorder", null); c(this, "chunks", []); c(this, "recordingBlob", null); c(this, "dataCallback", null); c(this, "stopCallback", null) } start(e) { this.mediaRecorder = new MediaRecorder(e), this.chunks = [], this.mediaRecorder.ondataavailable = n => { var i; n.data && n.data.size > 0 && (this.chunks.push(n.data), (i = this.dataCallback) == null || i.call(this, n.data)) }, this.mediaRecorder.onstop = () => { var i, r; const n = new Blob(this.chunks, { type: (i = this.mediaRecorder) == null ? void 0 : i.mimeType }); (r = this.stopCallback) == null || r.call(this, n) }, this.mediaRecorder.start() } stop() { return new Promise(e => { this.mediaRecorder && this.mediaRecorder.state === "recording" ? (this.mediaRecorder.onstop = () => { var n, i; this.recordingBlob = new Blob(this.chunks, { type: (n = this.mediaRecorder) == null ? void 0 : n.mimeType }), (i = this.stopCallback) == null || i.call(this, this.recordingBlob), e(this.recordingBlob) }, this.mediaRecorder.stop()) : e(new Blob) }) } pause() { this.mediaRecorder && this.mediaRecorder.state === "recording" && this.mediaRecorder.pause() } resume() { this.mediaRecorder && this.mediaRecorder.state === "paused" && this.mediaRecorder.resume() } get mimeType() { var e; return (e = this.mediaRecorder) == null ? void 0 : e.mimeType } get recordingState() { var e; return (e = this.mediaRecorder) == null ? void 0 : e.state } onData(e) { this.dataCallback = e } onStop(e) { this.stopCallback = e } get chunksBlob() { var e; return new Blob(this.chunks, { type: (e = this.mediaRecorder) == null ? void 0 : e.mimeType }) } mimeTypeToFileExtension(e) { switch (e.split(";", 1)[0]) { case "video/mp4": return "mp4"; case "video/webm": return "webm"; case "video/x-matroska": return "mkv"; default: throw new Error(`unsupported mimetype: ${e}`) } } download(e) { var r; if (!(this.recordingBlob && ((r = this.mediaRecorder) != null && r.mimeType))) return; const n = URL.createObjectURL(this.recordingBlob), i = document.createElement("a"); i.href = n, i.download = `${e}.${this.mimeTypeToFileExtension(this.mediaRecorder.mimeType)}`, i.style.display = "none", document.body.appendChild(i), i.click(), document.body.removeChild(i), URL.revokeObjectURL(n) } } let v = null; const l = new Ee; function u(t, e, n, i = !1) { const r = document.createElement("button"); return r.id = e, r.disabled = i, r.innerText = t, r.addEventListener("click", n), r } function Ce(t, e) { const n = document.createElement("video"); return n.id = e, n.srcObject = t, n.autoplay = !0, n.controls = !0, n.style.width = "100%", n.style.height = "100%", n } function d(t, e) { const n = document.querySelector(`#${t}`); n.disabled = e } function we() { const t = document.querySelector("#recording-toggle-user-video-btn"); t.disabled = !1, t.innerText = "Disable User Video" } function Ue() { const t = document.querySelector("#recording-toggle-user-audio-btn"); t.disabled = !1, t.innerText = "Disable User Audio" } function Ie() { d("recording-stop-local-user-stream-btn", !1) } function ke() { d("recording-local-user-stream-video-btn", !1) } function M() { d("start-recording-btn", !1) } function j() { d("pause-recording-btn", !1) } function Te() { d("resume-recording-btn", !1) } function Be() { d("stop-recording-btn", !1) } function F() { d("download-recording-btn", !1) } function Re() { d("start-recording-btn", !0) } function G() { d("pause-recording-btn", !0) } function z() { d("resume-recording-btn", !0) } function Ae() { d("stop-recording-btn", !0) } function _e() { d("download-recording-btn", !0) } function $e() { const t = document.querySelector("#recording-toggle-user-audio-btn"); t.disabled = !0, t.innerText = "Enable User Audio" } function qe() { const t = document.querySelector("#recording-toggle-user-video-btn"); t.disabled = !0, t.innerText = "Enable User Video" } function Ve() { const t = document.querySelector("video#stream-video"); t && (t.srcObject = null, t.remove()) } function Le() { return u("Stop local user stream", "recording-stop-local-user-stream-btn", async t => { if (t.target.disabled = !0, ke(), $e(), qe(), Ve(), s.instance.stopMediaStream(), v = null, l.recordingState === "recording") { await l.stop(), G(), z(), Ae(); const e = await l.stop(); console.log("Recording stopped. Blob:", e), F() } else Re() }, !0) } function Pe() { return u("Start Recording", "start-recording-btn", async t => { if (!v) { window.alert("No stream available. Please start the local user stream first."); return } t.target.disabled = !0, l.start(v), j(), Be(), _e() }, !0) } function Oe() { return u("Pause Recording", "pause-recording-btn", async t => { t.target.disabled = !0, l.pause(), Te() }, !0) } function xe() { return u("Resume Recording", "resume-recording-btn", async t => { t.target.disabled = !0, l.resume(), j() }, !0) } function Me() { return u("Stop Recording", "stop-recording-btn", async t => { t.target.disabled = !0; const e = await l.stop(); console.log("Recording stopped. Blob:", e), M(), G(), z(), F() }, !0) } function je() { return u("Download Recording", "download-recording-btn", async t => { l.download("recording") }, !0) } function Fe(t) { s.instance.toggleUserTrack("audio"); const e = s.instance.isUserTrackEnabled("audio"); t.target.innerText = e ? "Disable User Audio" : "Enable User Audio" } function Ge() { return u("Disable User Audio", "recording-toggle-user-audio-btn", Fe, !0) } function ze(t) { s.instance.toggleUserTrack("video"); const e = s.instance.isUserTrackEnabled("video"); t.target.innerText = e ? "Disable User Video" : "Enable User Video" } function He() { return u("Disable Video", "recording-toggle-user-video-btn", ze, !0) } function Ne() { return u("Get local user video stream", "recording-local-user-stream-video-btn", async t => { t.target.disabled = !0; try { v = await s.instance.getUserMedia({ video: !0, audio: !0 }) } catch (n) { t.target.disabled = !1, n.name === "NotAllowedError" ? window.alert("User denied permission to share video") : window.alert("Failed to get video stream: " + n); return } document.querySelector(".recording-container").appendChild(Ce(v, "stream-video")), Ie(), Ue(), we(), M() }) } function Ke() { const t = document.createElement("div"); t.className = "recording-container"; const e = document.createElement("h2"); return e.innerText = "Recording Demo", t.appendChild(e), t.appendChild(Ne()), t.appendChild(Le()), t.appendChild(Ge()), t.appendChild(He()), t.appendChild(Pe()), t.appendChild(Oe()), t.appendChild(xe()), t.appendChild(Me()), t.appendChild(je()), t } const T = document.querySelector("#app"); T.appendChild(Q()); T.appendChild(De()); T.appendChild(Ke());
